# Database Migration Management

**Status:** ‚úÖ **IMPLEMENTED** (October 25, 2025)
**Purpose:** Automated migration management with tracking, validation, and CI/CD integration
**Migration System:** Fully automated with checksum validation and environment isolation

---

## System Overview

**What We Have:**
```
server/src/db/
‚îú‚îÄ‚îÄ migrate.js                          # Automated migration runner
‚îî‚îÄ‚îÄ migrations/
    ‚îú‚îÄ‚îÄ 000-create-migration-table.sql  # Migration tracking system
    ‚îú‚îÄ‚îÄ 001-create-users-table.sql      # Users + session tables
    ‚îî‚îÄ‚îÄ 002-add-reset-token-fields.sql  # Password reset fields
```

**Key Features:**
‚úÖ **Migration tracking** via `schema_migrations` table
‚úÖ **Automatic execution** on Vercel deployment (via build command)
‚úÖ **Checksum validation** prevents accidental modification
‚úÖ **Environment isolation** (dev, preview, production databases)
‚úÖ **Idempotent SQL** safe to run multiple times
‚úÖ **Transaction wrapping** automatic rollback on failure
‚úÖ **Public status endpoint** for monitoring (`/api/migration-status`)
‚úÖ **Admin endpoint** for manual runs (secure Bearer auth)

**How It Works:**
1. Developer creates numbered `.sql` file in `migrations/`
2. Test locally: `npm run migrate`
3. Commit and push to git
4. **Migrations run automatically during Vercel build** ‚úÖ
5. Build fails if migrations fail (safety first!)
6. Migration tracking prevents duplicate execution

**Benefits:**
‚úÖ Zero manual intervention required in production
‚úÖ Complete audit trail with execution times
‚úÖ Safe multi-environment workflows
‚úÖ Prevents schema drift between environments

---

## Architecture

### 1. Migration Tracking Table

**Status:** ‚úÖ Implemented in `000-create-migration-table.sql`

```sql
-- server/src/db/migrations/000-create-migration-table.sql
CREATE TABLE IF NOT EXISTS schema_migrations (
  id SERIAL PRIMARY KEY,
  version VARCHAR(255) UNIQUE NOT NULL,  -- e.g., "001-add-reset-token-fields"
  name VARCHAR(255) NOT NULL,             -- Human-readable description
  applied_at TIMESTAMP DEFAULT NOW(),
  execution_time_ms INTEGER,              -- Performance tracking
  checksum VARCHAR(64)                    -- Verify file hasn't changed
);

CREATE INDEX idx_schema_migrations_version ON schema_migrations(version);
```

**What It Tracks:**
- ‚úÖ Version number and migration name
- ‚úÖ Timestamp when applied
- ‚úÖ Execution time (performance monitoring)
- ‚úÖ SHA-256 checksum (file integrity verification)

### 2. Migration File Naming Convention

**Status:** ‚úÖ Implemented - all migrations follow this format

**Format:** `{NNN}-{description}.sql` (3-digit zero-padded version)

```
migrations/
‚îú‚îÄ‚îÄ 000-create-migration-table.sql  ‚úÖ Implemented
‚îú‚îÄ‚îÄ 001-create-users-table.sql      ‚úÖ Implemented
‚îú‚îÄ‚îÄ 002-add-reset-token-fields.sql  ‚úÖ Implemented
‚îî‚îÄ‚îÄ 003-add-usage-tracking.sql      üìã Future (Epic 2.2)
```

**Rules:**
- ‚úÖ Version number: 3-digit zero-padded (000, 001, 002)
- ‚úÖ Description: kebab-case, descriptive
- ‚úÖ Run in alphabetical/numerical order
- ‚úÖ **Never modify existing migrations** (create new ones)
- ‚úÖ Include header comment with version, date, description

### 3. Automated Migration Runner

**Status:** ‚úÖ Implemented in `server/src/db/migrate.js`

**Features:**
```javascript
/**
 * Automated Migration Runner
 *
 * Features:
 * - Discovers all .sql files in migrations/
 * - Checks schema_migrations table for applied migrations
 * - Runs only pending migrations in order
 * - Records each successful migration
 * - Atomic transactions (rollback on failure)
 * - Checksum validation
 */

// High-level algorithm:
async function migrate() {
  // 1. Ensure schema_migrations table exists
  await ensureMigrationTableExists();

  // 2. Get list of all migration files
  const allMigrations = await getMigrationFiles();

  // 3. Get list of applied migrations from database
  const appliedMigrations = await getAppliedMigrations();

  // 4. Determine pending migrations
  const pending = allMigrations.filter(m =>
    !appliedMigrations.includes(m.version)
  );

  // 5. Run each pending migration in transaction
  for (const migration of pending) {
    await runMigrationInTransaction(migration);
  }

  // 6. Report results
  console.log(`‚úÖ ${pending.length} migrations applied successfully`);
}
```

**Key Implementation Details:**

```javascript
// Migration file structure
interface Migration {
  version: string;        // "001-create-users-table"
  filename: string;       // "001-create-users-table.sql"
  name: string;          // "Create users table"
  sql: string;           // SQL file contents
  checksum: string;      // MD5 hash of SQL
}

// Run migration in transaction
async function runMigrationInTransaction(migration) {
  const client = await pool.connect();

  try {
    await client.query('BEGIN');

    const startTime = Date.now();

    // Execute migration SQL
    await client.query(migration.sql);

    const executionTime = Date.now() - startTime;

    // Record in schema_migrations
    await client.query(`
      INSERT INTO schema_migrations (version, name, execution_time_ms, checksum)
      VALUES ($1, $2, $3, $4)
    `, [migration.version, migration.name, executionTime, migration.checksum]);

    await client.query('COMMIT');

    console.log(`‚úÖ Applied: ${migration.version} (${executionTime}ms)`);

  } catch (error) {
    await client.query('ROLLBACK');
    throw new Error(`Migration ${migration.version} failed: ${error.message}`);
  } finally {
    client.release();
  }
}
```

### 4. Checksum Validation

**Status:** ‚úÖ Implemented with SHA-256

**Purpose:** Prevent accidental modification of applied migrations

```javascript
import crypto from 'crypto';

// Uses SHA-256 (not MD5) for better security
function calculateChecksum(sql) {
  return crypto.createHash('sha256').update(sql, 'utf8').digest('hex');
}

// Validation runs automatically on every migration attempt
async function validateMigrationIntegrity() {
  const appliedMigrations = await getAppliedMigrations();

  for (const applied of appliedMigrations) {
    const currentFile = readMigrationFile(applied.version);
    const currentChecksum = calculateChecksum(currentFile.sql);

    if (currentChecksum !== applied.checksum) {
      throw new Error(
        `Migration ${applied.version} has been modified after being applied! ` +
        `This is dangerous and could cause inconsistencies.`
      );
    }
  }
}
```

**Implementation Details:**
- ‚úÖ Checksum calculated on migration run
- ‚úÖ Stored in `schema_migrations.checksum` column
- ‚úÖ Verified before running pending migrations
- ‚úÖ Throws error if file modified post-application

### 5. CLI Interface

**Status:** ‚úÖ Implemented in `server/package.json`

**Available Commands:**

```bash
# Run all pending migrations
npm run migrate

# Show migration status (applied/pending)
npm run migrate:status

# Validate migration integrity (checksum verification)
npm run migrate:validate
```

**Implementation in package.json:**

```json
{
  "scripts": {
    "migrate": "node -r dotenv/config src/db/migrate.js",
    "migrate:status": "node -r dotenv/config src/db/migrate.js status",
    "migrate:validate": "node -r dotenv/config src/db/migrate.js validate"
  }
}
```

**Not Yet Implemented (Future Enhancements):**
- üìã `migrate:create "description"` - Auto-generate migration template
- üìã `migrate:rollback` - Rollback capability (forward-only approach preferred)

### 6. Status Command

**Status:** ‚úÖ Implemented - shows applied/pending migrations with execution times

**Example Output:**

```bash
$ cd server && npm run migrate:status

üìä Migration Status

Database: neondb
Environment: development

Applied Migrations (3):
‚úÖ 000-create-migration-table          (10/25/2025, 2:00:17 PM) - 25ms
‚úÖ 001-create-users-table              (10/25/2025, 2:01:28 PM) - 46ms
‚úÖ 002-add-reset-token-fields          (10/25/2025, 2:01:28 PM) - 27ms

Pending Migrations: None
```

**Production Status (Public Endpoint):**
```bash
$ curl https://codescribeai.com/api/migration-status

{
  "success": true,
  "environment": "production",
  "database": "neondb",
  "appliedMigrations": 3,
  "pendingMigrations": 0,
  "lastMigration": {
    "version": "002-add-reset-token-fields",
    "appliedAt": "2025-10-25T19:05:12.455Z"
  }
}
```

---

## Integration with Deployment

### Current Implementation: Automatic Migrations via Build Command

**Status:** ‚úÖ Implemented in `vercel.json`

**Configuration:**
```json
{
  "buildCommand": "cd server && npm install && npm run migrate && cd ../client && npm install && npm run build"
}
```

**How It Works:**
1. ‚úÖ Vercel triggers deployment (git push)
2. ‚úÖ Installs server dependencies
3. ‚úÖ **Runs `npm run migrate`** (applies pending migrations)
4. ‚úÖ Installs client dependencies
5. ‚úÖ Builds frontend
6. ‚úÖ Deploys if all steps succeed
7. ‚úÖ **Build fails if migrations fail** (safety first!)

**Benefits:**
‚úÖ Automatic migration on every deploy
‚úÖ Zero manual intervention required
‚úÖ Build fails if migration fails (prevents incompatible deployments)
‚úÖ Migration logs visible in Vercel build output
‚úÖ Works seamlessly with CI/CD

**Limitations:**
‚ö†Ô∏è Blocks deployment if migration fails
‚ö†Ô∏è No preview of migrations before deploy (use `migrate:status` locally first)

### Alternative: Manual Admin Endpoint

**Status:** ‚úÖ Implemented for emergency use

**For manual migration runs (rare scenarios):**

```bash
# Run pending migrations manually
curl -X POST \
  -H "Authorization: Bearer YOUR_MIGRATION_SECRET" \
  https://codescribeai.com/api/migrate

# Check detailed migration status
curl -X POST \
  -H "Authorization: Bearer YOUR_MIGRATION_SECRET" \
  -H "Content-Type: application/json" \
  -d '{"action":"status"}' \
  https://codescribeai.com/api/migrate
```

**When to Use:**
- Emergency migration run without redeploying
- Testing migrations in production (not recommended)
- Debugging migration issues

**Security:**
- ‚úÖ Secure header-based authentication (Bearer token)
- ‚úÖ Secret never appears in URLs or logs
- ‚úÖ POST-only endpoint (no accidental GET requests)
- ‚úÖ Secret stored in Vercel environment variables

### Future Enhancement: GitHub Actions Workflow

**Status:** üìã Future consideration (not needed currently)

**Could add for:**
- Pre-deployment migration checks
- Automated migration testing
- Separate migration step from build
- More granular control over deployment flow

**Trade-offs:**
- ‚úÖ More explicit migration control
- ‚úÖ Can test migrations before deploy
- ‚ö†Ô∏è Adds complexity
- ‚ö†Ô∏è Current approach (build-time migrations) works well for our use case

---

## Multi-Environment Strategy

**Status:** ‚úÖ Implemented - Complete database isolation

### Separate Databases per Environment

**Current Configuration:**

```bash
# Local Development (server/.env)
POSTGRES_URL=postgresql://neondb_owner:xxx@ep-dev-abc123-pooler.us-east-1.aws.neon.tech/neondb

# Preview/Staging (Vercel Environment Variables - Preview)
POSTGRES_URL=postgresql://neondb_owner:yyy@ep-preview-def456-pooler.us-east-1.aws.neon.tech/neondb

# Production (Vercel Environment Variables - Production)
POSTGRES_URL=postgresql://neondb_owner:zzz@ep-prod-xyz789-pooler.us-east-1.aws.neon.tech/neondb
```

**Key Features:**
- ‚úÖ Each environment has unique Neon database with different endpoint ID
- ‚úÖ Complete isolation (no cross-contamination)
- ‚úÖ Vercel automatically injects correct `POSTGRES_URL` based on deployment environment
- ‚úÖ `@vercel/postgres` SDK reads environment variables automatically

### Migration Workflow

**Current Process:**

```
1. Developer creates migration locally
   ‚îú‚îÄ‚îÄ Create: 003-add-usage-tracking.sql
   ‚îú‚îÄ‚îÄ Test locally: npm run migrate
   ‚îî‚îÄ‚îÄ Verify with: npm run migrate:status

2. Commit and push to git
   ‚îú‚îÄ‚îÄ git add server/src/db/migrations/003-add-usage-tracking.sql
   ‚îú‚îÄ‚îÄ git commit -m "Add usage tracking migration"
   ‚îî‚îÄ‚îÄ git push origin main

3. Vercel deployment (automatic)
   ‚îú‚îÄ‚îÄ Build starts
   ‚îú‚îÄ‚îÄ npm run migrate executes (applies to production DB)
   ‚îú‚îÄ‚îÄ Build completes
   ‚îî‚îÄ‚îÄ Deployment succeeds

4. Verify in production
   ‚îú‚îÄ‚îÄ Check build logs in Vercel Dashboard
   ‚îî‚îÄ‚îÄ Visit: https://codescribeai.com/api/migration-status
```

**Benefits:**
‚úÖ Simple, straightforward workflow
‚úÖ No manual production migration step
‚úÖ Build fails if migration fails (safety)
‚úÖ Complete audit trail in Vercel logs

### Environment-Specific Migrations

**Status:** Not needed currently (all migrations run in all environments)

**If needed in future:**

```sql
-- migrations/004-add-usage-tracking.sql
-- Example: Skip in test environments
DO $$
BEGIN
  IF current_database() NOT LIKE '%test%' THEN
    CREATE TABLE IF NOT EXISTS usage_stats (
      id SERIAL PRIMARY KEY,
      user_id INTEGER REFERENCES users(id),
      action VARCHAR(50),
      created_at TIMESTAMP DEFAULT NOW()
    );
  END IF;
END $$;
```

**Best Practice:** Keep migrations uniform across environments when possible

---

## Rollback Strategy

**Current Approach:** ‚úÖ Forward-Only (Recommended)

### Why Forward-Only?

**Philosophy:** Never rollback, always move forward

**Example:**
```
Problem: Migration 002 added wrong column type

Solution: Create migration 003 to fix it
‚îú‚îÄ‚îÄ 002-add-reset-token-fields.sql        (original migration)
‚îî‚îÄ‚îÄ 003-fix-reset-token-column-type.sql   (correction migration)
```

**Benefits:**
‚úÖ Simpler to reason about
‚úÖ No data loss
‚úÖ Clear audit trail
‚úÖ Matches production reality (can't undo deployed migrations)
‚úÖ Safer for production environments
‚úÖ Works with automatic deployments

**Trade-offs:**
‚ö†Ô∏è More migration files over time (minimal impact)
‚ö†Ô∏è Can't truly "undo" a migration (create corrective migration instead)

### Alternative: Down Migrations (Not Implemented)

**Status:** üìã Future consideration if needed

**Would require:**
- Paired `.up.sql` and `.down.sql` files
- Rollback command (`migrate:rollback`)
- Tracking of rollback operations
- More complex migration system

**Drawbacks:**
- ‚ö†Ô∏è Double the migration files
- ‚ö†Ô∏è Potential data loss on rollback (DROP TABLE)
- ‚ö†Ô∏è More complex to maintain
- ‚ö†Ô∏è Not needed for our current use case

---

## Why Custom Implementation vs Existing Tools?

**Decision:** Built custom migration system instead of using Prisma/node-pg-migrate/Knex

### Rationale

**What we wanted:**
‚úÖ Simple SQL files (no abstraction layer)
‚úÖ Minimal dependencies (@vercel/postgres only)
‚úÖ Full control over migration logic
‚úÖ Easy integration with Vercel deployment
‚úÖ No ORM lock-in

**What we built:**
‚úÖ ~200 lines of code in `migrate.js`
‚úÖ Complete migration tracking
‚úÖ Checksum validation
‚úÖ Transaction safety
‚úÖ CLI commands
‚úÖ Public status endpoint
‚úÖ Admin endpoint for manual runs

**Benefits vs Existing Tools:**
- ‚úÖ No additional dependencies (Prisma, Knex, etc.)
- ‚úÖ Keep pure SQL (no schema DSL to learn)
- ‚úÖ Customize for our exact needs
- ‚úÖ Lighter weight (no ORM overhead)
- ‚úÖ Simple to understand and maintain

### When to Consider Existing Tools

**Prisma Migrate** - If you want type-safe ORM + automatic migration generation
**node-pg-migrate** - If you need rollback support out of the box
**Knex.js** - If already using Knex for queries

**For our use case:** Custom solution was simpler and met all requirements

---

## Implementation Status

**Status:** ‚úÖ **COMPLETE** (October 25, 2025)

**Phase 1: Setup** ‚úÖ Complete
- [x] Create `schema_migrations` table migration (000-create-migration-table.sql)
- [x] Implement file naming convention (NNN-description.sql)
- [x] Build `migrate.js` script with core functionality
- [x] Add `npm run migrate` command
- [x] Test on development database

**Phase 2: Status & Validation** ‚úÖ Complete
- [x] Implement `migrate:status` command
- [x] Add checksum validation (SHA-256)
- [x] Create `migrate:validate` command
- [x] Test with existing migrations

**Phase 3: Documentation** ‚úÖ Complete
- [x] Document migration workflow (PRODUCTION-DB-SETUP.md)
- [x] Update deployment docs
- [x] Create comprehensive migration guide (this document)
- [x] Add related documentation links

**Phase 4: CI/CD Integration** ‚úÖ Complete
- [x] Add migration step to vercel.json build command
- [x] Configure environment-based database routing
- [x] Test migration workflow on production
- [x] Create public status endpoint (/api/migration-status)
- [x] Create admin endpoint with Bearer auth (/api/migrate)

**Phase 5: Production Deployment** ‚è≥ In Progress
- [x] Test on development database (codescribe-db)
- [ ] Create production database in Vercel
- [ ] Add MIGRATION_SECRET environment variable
- [ ] Deploy to production
- [ ] Verify migrations run successfully

**Total Implementation Time:** ~8 hours (completed October 24-25, 2025)

---

## Database Environments & Testing Workflow

### Three-Tier Environment Strategy

**CodeScribe AI uses three database environments for safe migration testing:**

| Environment | Database | Connection | Purpose |
|-------------|----------|------------|---------|
| **Sandbox (Docker)** | `codescribe_test` | `localhost:5433` | Isolated testing, fully disposable |
| **Dev (Neon)** | `neondb` | Neon pooler endpoint | Persistent development database |
| **Production (Neon)** | `neondb` | Neon pooler endpoint | Live production database |

### Clear Terminology

**üê≥ Sandbox DB Migration (Docker only)**
```bash
# Start isolated test database
docker-compose -f docker-compose.test.yml up -d

# Apply migration directly via psql
docker exec -i codescribe-test-db psql -U test_user -d codescribe_test < src/db/migrations/006-new-migration.sql

# Verify results
docker exec codescribe-test-db psql -U test_user -d codescribe_test -c "\d table_name"

# Cleanup (destroys all data)
docker-compose -f docker-compose.test.yml down -v
```
**When to use:** Initial migration testing, can break things safely

**üîß Dev Migration (Neon dev database)**
```bash
# Apply to persistent dev database
npm run migrate

# Check migration status
npm run migrate:status

# Validate integrity
npm run migrate:validate
```
**When to use:** After sandbox testing passes, before committing to git

**üöÄ Production Migration (Automatic)**
```bash
# Triggered automatically during Vercel deployment
# Runs as part of build command: npm run migrate && npm run build
```
**When to use:** Never manually! Happens on git push to main

### Migration Testing Workflow

**Recommended Process:**

```bash
# 1. Create migration file
# server/src/db/migrations/007-add-new-feature.sql

# 2. Test in Docker sandbox first (isolated, safe to break)
docker-compose -f docker-compose.test.yml up -d
docker exec -i codescribe-test-db psql -U test_user -d codescribe_test < src/db/migrations/007-add-new-feature.sql

# Verify it worked
docker exec codescribe-test-db psql -U test_user -d codescribe_test -c "SELECT * FROM new_table LIMIT 1;"

# 3. If sandbox test passes, apply to Neon dev
npm run migrate

# 4. Commit and push (production runs automatically)
git add src/db/migrations/007-add-new-feature.sql
git commit -m "Add migration 007: new feature"
git push origin main
# ‚Üí GitHub Actions tests ‚Üí Vercel deploys ‚Üí Migration runs automatically
```

### AI Assistant Protocol

**For Claude/AI assistants working on this codebase:**

| User Says | AI Should Do | Commands |
|-----------|--------------|----------|
| "Test migration in sandbox" | Docker only, ask before touching Neon | `docker exec ... psql` |
| "Run sandbox migration test" | Docker only, ask before touching Neon | `docker exec ... psql` |
| "Apply dev migration" | Run npm migrate on Neon dev | `npm run migrate` |
| "Deploy migration" | Remind: happens automatically | Nothing (explain workflow) |

**Default behavior:** Always test in Docker first, then explicitly ask:
> "‚úÖ Docker sandbox tests passed! Ready to apply to Neon dev database? (This will run `npm run migrate`)"

### Docker Test Database Setup

**Configuration:**
```yaml
# docker-compose.test.yml
services:
  postgres-test:
    image: postgres:16
    container_name: codescribe-test-db
    environment:
      POSTGRES_DB: codescribe_test
      POSTGRES_USER: test_user
      POSTGRES_PASSWORD: test_password
    ports:
      - "5433:5432"  # Different port to avoid conflicts
    tmpfs:
      - /var/lib/postgresql/data:rw,size=256m  # In-memory for speed
```

**Connection String:**
```bash
# .env.test (for Docker)
POSTGRES_URL=postgresql://test_user:test_password@localhost:5433/codescribe_test
```

**Helpful Commands:**
```bash
# Start test DB
npm run test:db:setup

# Stop test DB (keeps data)
npm run test:db:teardown

# Reset test DB (destroys all data)
npm run test:db:reset

# Run database integration tests
npm run test:db
```

---

## Testing Strategy

### Unit Tests

```javascript
// server/src/db/__tests__/migrate.test.js
describe('Migration System', () => {
  it('should detect pending migrations', async () => {
    const pending = await getPendingMigrations();
    expect(pending).toHaveLength(2);
  });

  it('should calculate checksums correctly', () => {
    const sql = 'CREATE TABLE users (id SERIAL);';
    const checksum = calculateChecksum(sql);
    expect(checksum).toBe('expected-md5-hash');
  });

  it('should run migration in transaction', async () => {
    await runMigrationInTransaction(testMigration);
    const applied = await getAppliedMigrations();
    expect(applied).toContainEqual(testMigration.version);
  });

  it('should rollback on migration failure', async () => {
    const badMigration = { sql: 'INVALID SQL;' };
    await expect(
      runMigrationInTransaction(badMigration)
    ).rejects.toThrow();

    // Verify rollback happened
    const tables = await getTables();
    expect(tables).not.toContain('new_table');
  });
});
```

### Integration Tests

```javascript
describe('Migration Integration', () => {
  it('should run all pending migrations', async () => {
    await migrate();
    const pending = await getPendingMigrations();
    expect(pending).toHaveLength(0);
  });

  it('should be idempotent', async () => {
    await migrate();
    await migrate(); // Run again
    // Should not throw errors
  });

  it('should detect modified migrations', async () => {
    // Modify applied migration file
    await expect(validateMigrationIntegrity()).rejects.toThrow(
      /has been modified/
    );
  });
});
```

---

## Troubleshooting

### Migration Stuck in "Running" State

**Cause:** Transaction not committed or rolled back

**Solution:**
```sql
-- Check for active transactions
SELECT * FROM pg_stat_activity WHERE state = 'active';

-- Kill stuck transaction if needed
SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE pid = XXX;
```

### Checksum Mismatch

**Cause:** Migration file was edited after being applied

**Solution:**
- Never edit applied migrations
- Create new migration to fix issues
- If in development only, delete from `schema_migrations` and re-run

### Migration Fails Midway

**Cause:** SQL error in migration

**Solution:**
- Transactions ensure automatic rollback
- Fix SQL in migration file
- Run again (idempotent)

---

## API Endpoints

### Public Status Endpoint

**URL:** `GET https://codescribeai.com/api/migration-status`
**Authentication:** None required (read-only)

**Response:**
```json
{
  "success": true,
  "environment": "production",
  "database": "neondb",
  "pgVersion": "PostgreSQL 16.x",
  "appliedMigrations": 3,
  "pendingMigrations": 0,
  "lastMigration": {
    "version": "002-add-reset-token-fields",
    "name": "Add Reset Token Fields",
    "appliedAt": "2025-10-25T19:05:12.455Z"
  },
  "migrations": [...]
}
```

### Admin Endpoint (Manual Migration Runs)

**URL:** `POST https://codescribeai.com/api/migrate`
**Authentication:** Bearer token (MIGRATION_SECRET)

**Run pending migrations:**
```bash
curl -X POST \
  -H "Authorization: Bearer YOUR_MIGRATION_SECRET" \
  https://codescribeai.com/api/migrate
```

**Get detailed status:**
```bash
curl -X POST \
  -H "Authorization: Bearer YOUR_MIGRATION_SECRET" \
  -H "Content-Type: application/json" \
  -d '{"action":"status"}' \
  https://codescribeai.com/api/migrate
```

---

## Related Documentation

- [PRODUCTION-DB-SETUP.md](PRODUCTION-DB-SETUP.md) - Step-by-step production database setup guide
- [migrate.js](../../server/src/db/migrate.js) - Automated migration runner source code
- [PASSWORD-RESET-SETUP.md](../authentication/PASSWORD-RESET-SETUP.md) - Authentication setup using migrations
- [vercel.json](../../vercel.json) - Build configuration with automatic migrations

---

## Quick Reference

```bash
# Local Development
cd server
npm run migrate              # Run pending migrations
npm run migrate:status       # Show migration status
npm run migrate:validate     # Validate checksums

# Creating New Migrations
# 1. Create file: server/src/db/migrations/003-add-usage-tracking.sql
# 2. Test locally: npm run migrate
# 3. Commit and push: git push origin main
# 4. Migrations run automatically on Vercel deployment

# Production Status
curl https://codescribeai.com/api/migration-status

# Manual Migration Run (Emergency Only)
curl -X POST -H "Authorization: Bearer SECRET" https://codescribeai.com/api/migrate
```

---

**Created:** October 24, 2025
**Updated:** October 25, 2025
**Status:** ‚úÖ Implemented and operational
**Next Steps:** Deploy production database (see PRODUCTION-DB-SETUP.md)
