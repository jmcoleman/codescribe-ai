import { describe, it, expect, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { QualityScoreModal } from '../QualityScore';

// Mock CopyButton components to avoid clipboard API issues in tests
vi.mock('../CopyButton', () => ({
  CopyButtonWithText: ({ label }) => (
    <button type="button" aria-label={`Copy ${label}`}>{label}</button>
  )
}));

// Mock FocusTrap to avoid focus-trap errors in tests
vi.mock('focus-trap-react', () => ({
  FocusTrap: ({ children }) => <div>{children}</div>
}));

describe('QualityScoreModal Component', () => {
  const mockQualityScore = {
    score: 85,
    grade: 'B',
    docType: 'README',
    breakdown: {
      overview: {
        points: 20,
        maxPoints: 20,
        status: 'complete',
        suggestion: 'Excellent overview provided'
      },
      installation: {
        points: 12,
        maxPoints: 15,
        status: 'partial',
        suggestion: 'Add more detailed installation steps'
      },
      examples: {
        points: 18,
        maxPoints: 20,
        status: 'complete',
        suggestion: 'Great usage examples'
      },
      apiDocs: {
        points: 15,
        maxPoints: 25,
        status: 'partial',
        suggestion: 'Include more API endpoint details'
      },
      structure: {
        points: 15,
        maxPoints: 20,
        status: 'partial',
        suggestion: 'Improve markdown formatting'
      }
    },
    summary: {
      topSuggestion: 'Consider adding more API documentation details',
      strengths: ['overview', 'examples'],
      improvements: ['installation', 'apiDocs', 'structure']
    },
    inputCodeHealth: {
      score: 25,
      grade: 'F',
      breakdown: {
        comments: {
          points: 8,
          maxPoints: 20,
          status: 'partial',
          count: 5,
          ratio: 5
        },
        naming: {
          points: 12,
          maxPoints: 20,
          status: 'partial',
          descriptiveRatio: 60
        },
        existingDocs: {
          points: 0,
          maxPoints: 25,
          status: 'missing',
          features: []
        },
        codeStructure: {
          points: 5,
          maxPoints: 35,
          status: 'missing',
          issues: ['Inconsistent indentation', 'Poor spacing']
        }
      }
    },
    improvement: 60
  };

  describe('Rendering', () => {
    it('should render modal when qualityScore is provided', () => {
      const onClose = vi.fn();
      render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} filename="test-file.js" />);

      expect(screen.getByText('Quality Breakdown')).toBeInTheDocument();
      expect(screen.getByText('85')).toBeInTheDocument();
      expect(screen.getByText('B')).toBeInTheDocument();
    });

    it('should return null when qualityScore is null', () => {
      const onClose = vi.fn();
      const { container } = render(<QualityScoreModal qualityScore={null} onClose={onClose} />);

      expect(container.firstChild).toBeNull();
    });

    it('should render modal header with title', () => {
      const onClose = vi.fn();
      render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} filename="test.js" />);

      expect(screen.getByRole('heading', { name: 'Quality Breakdown' })).toBeInTheDocument();
    });

    it('should render close button', () => {
      const onClose = vi.fn();
      render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} filename="test.js" />);

      const closeButton = screen.getByRole('button', { name: /close quality breakdown modal/i });
      expect(closeButton).toBeInTheDocument();
    });
  });

  describe('Overall Score Display', () => {
    it('should display correct score', () => {
      const onClose = vi.fn();
      render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} filename="test.js" />);

      expect(screen.getByText('85')).toBeInTheDocument();
    });

    it('should display correct grade', () => {
      const onClose = vi.fn();
      render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} filename="test.js" />);

      expect(screen.getByText('B')).toBeInTheDocument();
    });


    it('should apply correct color for A grade', () => {
      const onClose = vi.fn();
      const scoreA = { ...mockQualityScore, score: 95, grade: 'A', inputCodeHealth: { ...mockQualityScore.inputCodeHealth } };
      render(<QualityScoreModal qualityScore={scoreA} onClose={onClose} filename="test.js" />);

      const gradeElements = screen.getAllByText('A');
      const outputGrade = gradeElements.find(el => el.classList.contains('text-purple-600'));
      expect(outputGrade).toBeInTheDocument();
    });

    it('should apply correct color for B grade', () => {
      const onClose = vi.fn();
      render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} filename="test.js" />);

      const gradeElement = screen.getByText('B');
      expect(gradeElement).toHaveClass('text-purple-600');
    });

    it('should apply correct color for C grade', () => {
      const onClose = vi.fn();
      const scoreC = { ...mockQualityScore, score: 75, grade: 'C', inputCodeHealth: { ...mockQualityScore.inputCodeHealth } };
      render(<QualityScoreModal qualityScore={scoreC} onClose={onClose} filename="test.js" />);

      const gradeElement = screen.getByText('C');
      expect(gradeElement).toHaveClass('text-purple-600');
    });

    it('should apply correct color for D grade', () => {
      const onClose = vi.fn();
      const scoreD = { ...mockQualityScore, score: 65, grade: 'D', inputCodeHealth: { ...mockQualityScore.inputCodeHealth } };
      render(<QualityScoreModal qualityScore={scoreD} onClose={onClose} filename="test.js" />);

      const gradeElement = screen.getByText('D');
      expect(gradeElement).toHaveClass('text-purple-600');
    });

    it('should apply correct color for F grade', () => {
      const onClose = vi.fn();
      const scoreF = { ...mockQualityScore, score: 45, grade: 'F', inputCodeHealth: { ...mockQualityScore.inputCodeHealth, score: 20 } };
      render(<QualityScoreModal qualityScore={scoreF} onClose={onClose} filename="test.js" />);

      // Look for the F grade in the output section (purple)
      const gradeElements = screen.getAllByText('F');
      const outputGrade = gradeElements.find(el => el.classList.contains('text-purple-600'));
      expect(outputGrade).toBeInTheDocument();
    });
  });

  describe('Criteria Breakdown', () => {
    it('should render all criteria items', async () => {
      const user = userEvent.setup();
      const onClose = vi.fn();
      render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} filename="test.js" />);

      // Click the Generated Documentation tab to see these criteria
      const outputTab = screen.getByRole('button', { name: /generated documentation/i });
      await user.click(outputTab);

      expect(screen.getByText('Overview')).toBeInTheDocument();
      expect(screen.getByText('Installation')).toBeInTheDocument();
      expect(screen.getByText('Usage Examples')).toBeInTheDocument();
      expect(screen.getByText('Code Documentation')).toBeInTheDocument();
      expect(screen.getByText('Structure & Formatting')).toBeInTheDocument();
    });

    it('should display points for each criterion', async () => {
      const user = userEvent.setup();
      const onClose = vi.fn();
      render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} filename="test.js" />);

      // Click the Generated Documentation tab
      const outputTab = screen.getByRole('button', { name: /generated documentation/i });
      await user.click(outputTab);

      // Display points out of maxPoints
      expect(screen.getByText('20/20')).toBeInTheDocument();
      expect(screen.getByText('12/15')).toBeInTheDocument();
      expect(screen.getByText('18/20')).toBeInTheDocument();
      expect(screen.getByText('15/25')).toBeInTheDocument();
      expect(screen.getByText('15/20')).toBeInTheDocument();
    });

    it('should display suggestions for each criterion', async () => {
      const user = userEvent.setup();
      const onClose = vi.fn();
      render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} filename="test.js" />);

      // Click the Generated Documentation tab
      const outputTab = screen.getByRole('button', { name: /generated documentation/i });
      await user.click(outputTab);

      expect(screen.getByText('Excellent overview provided')).toBeInTheDocument();
      expect(screen.getByText('Add more detailed installation steps')).toBeInTheDocument();
      expect(screen.getByText('Great usage examples')).toBeInTheDocument();
      expect(screen.getByText('Include more API endpoint details')).toBeInTheDocument();
      expect(screen.getByText('Improve markdown formatting')).toBeInTheDocument();
    });

    it('should show complete status icon for complete criteria', () => {
      const onClose = vi.fn();
      const { container } = render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} filename="test.js" />);

      // Find the complete status icon (slate check circle)
      const svgIcon = container.querySelector('svg.text-slate-600');
      expect(svgIcon).toBeInTheDocument();
    });

    it('should show partial status icon for partial criteria', () => {
      const onClose = vi.fn();
      const { container } = render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} filename="test.js" />);

      // Find the partial status icon (slate alert triangle)
      const svgIcons = container.querySelectorAll('svg.text-slate-600');
      expect(svgIcons.length).toBeGreaterThan(0);
    });

    it('should render progress bars for each criterion', () => {
      const onClose = vi.fn();
      const { container } = render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} />);

      const progressBars = container.querySelectorAll('.bg-slate-100.rounded-full');
      expect(progressBars.length).toBe(5); // One for each criterion
    });

    it('should calculate correct progress bar width', () => {
      const onClose = vi.fn();
      const { container } = render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} />);

      const progressBars = container.querySelectorAll('.h-full.transition-all');
      // Check that progress bars exist and have width set
      expect(progressBars.length).toBe(5);
      // Check calculated percentages based on points/maxPoints
      expect(progressBars[0].style.width).toBe('100%'); // overview: 20/20
      expect(progressBars[1].style.width).toBe('80%');  // installation: 12/15
      expect(progressBars[2].style.width).toBe('90%');  // examples: 18/20
      expect(progressBars[3].style.width).toBe('60%');  // apiDocs: 15/25
      expect(progressBars[4].style.width).toBe('75%');  // structure: 15/20
    });

    it('should apply purple color for all progress bars', () => {
      const onClose = vi.fn();
      const { container } = render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} filename="test.js" />);

      const progressBars = container.querySelectorAll('.h-full.transition-all');
      // All progress bars should be purple
      progressBars.forEach(bar => {
        expect(bar.classList.contains('bg-purple-500') || bar.classList.contains('bg-purple-400')).toBe(true);
      });
    });
  });

  describe('Close Functionality', () => {
    it('should call onClose when close button clicked', async () => {
      const user = userEvent.setup();
      const onClose = vi.fn();
      render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} />);

      const closeButton = screen.getByRole('button', { name: /close quality breakdown modal/i });
      await user.click(closeButton);

      expect(onClose).toHaveBeenCalledTimes(1);
    });

    it('should call onClose when Escape key pressed', async () => {
      const user = userEvent.setup();
      const onClose = vi.fn();
      render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} />);

      await user.keyboard('{Escape}');

      expect(onClose).toHaveBeenCalledTimes(1);
    });

    it('should have accessible close button', () => {
      const onClose = vi.fn();
      render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} />);

      const closeButton = screen.getByRole('button', { name: /close quality breakdown modal/i });
      expect(closeButton).toBeInTheDocument();
      expect(closeButton.querySelector('svg')).toBeInTheDocument(); // X icon
    });

    it('should have aria-label on close button', () => {
      const onClose = vi.fn();
      render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} />);

      const closeButton = screen.getByLabelText('Close quality breakdown modal');
      expect(closeButton).toBeInTheDocument();
    });

    it('should have hover effect on close button', () => {
      const onClose = vi.fn();
      render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} />);

      const closeButton = screen.getByRole('button', { name: /close quality breakdown modal/i });
      expect(closeButton).toHaveClass('hover:bg-purple-50');
    });
  });

  describe('Modal Styling', () => {
    it('should have modal overlay with correct styling', () => {
      const onClose = vi.fn();
      const { container } = render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} />);

      const overlay = container.querySelector('.fixed.inset-0');
      expect(overlay).toHaveClass('bg-black/50', 'flex', 'items-center', 'justify-center', 'z-50');
    });

    it('should have modal content with correct styling', () => {
      const onClose = vi.fn();
      const { container } = render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} />);

      const modal = container.querySelector('.bg-white.rounded-xl');
      expect(modal).toHaveClass('shadow-2xl', 'max-w-md', 'w-full', 'max-h-[90vh]', 'flex', 'flex-col');
    });

    it('should have scrollable criteria section', () => {
      const onClose = vi.fn();
      const { container } = render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} />);

      const criteriaSection = container.querySelector('.overflow-y-auto.flex-1');
      expect(criteriaSection).toBeInTheDocument();
    });

    it('should have gradient background for score section', () => {
      const onClose = vi.fn();
      const { container } = render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} />);

      const scoreSection = container.querySelector('.bg-gradient-to-br.from-purple-50');
      expect(scoreSection).toBeInTheDocument();
    });
  });

  describe('Edge Cases', () => {
    it('should handle missing suggestion field gracefully', () => {
      const onClose = vi.fn();
      const scoreWithoutSuggestions = {
        ...mockQualityScore,
        breakdown: {
          overview: {
            points: 20,
            status: 'complete'
            // No suggestion field
          }
        }
      };

      render(<QualityScoreModal qualityScore={scoreWithoutSuggestions} onClose={onClose} />);

      expect(screen.getByText('Overview')).toBeInTheDocument();
      expect(screen.getByText('20/20')).toBeInTheDocument();
    });

    it('should handle missing summary fields gracefully', () => {
      const onClose = vi.fn();
      const scoreWithoutSummary = {
        ...mockQualityScore,
        summary: {
          improvements: []
        }
      };

      expect(() => {
        render(<QualityScoreModal qualityScore={scoreWithoutSummary} onClose={onClose} />);
      }).not.toThrow();
    });

    it('should handle zero score', () => {
      const onClose = vi.fn();
      const zeroScore = {
        ...mockQualityScore,
        score: 0,
        grade: 'F'
      };
      render(<QualityScoreModal qualityScore={zeroScore} onClose={onClose} />);

      expect(screen.getByText('0/100')).toBeInTheDocument();
      expect(screen.getByText('Grade: F')).toBeInTheDocument();
    });

    it('should handle perfect score', () => {
      const onClose = vi.fn();
      const perfectScore = {
        score: 100,
        grade: 'A',
        breakdown: {
          overview: { points: 20, maxPoints: 20, status: 'complete' }
        },
        summary: {
          topSuggestion: 'Perfect documentation!',
          strengths: ['overview'],
          improvements: []
        }
      };
      render(<QualityScoreModal qualityScore={perfectScore} onClose={onClose} />);

      expect(screen.getByText('100/100')).toBeInTheDocument();
      expect(screen.getByText('Grade: A')).toBeInTheDocument();
    });

    it('should handle empty breakdown object', () => {
      const onClose = vi.fn();
      const emptyBreakdown = {
        ...mockQualityScore,
        breakdown: {}
      };

      render(<QualityScoreModal qualityScore={emptyBreakdown} onClose={onClose} />);

      // Should still render the modal
      expect(screen.getByText('Quality Breakdown')).toBeInTheDocument();
    });

    it('should handle unknown criteria names', () => {
      const onClose = vi.fn();
      const unknownCriteria = {
        ...mockQualityScore,
        breakdown: {
          unknownField: {
            points: 10,
            maxPoints: 20,
            status: 'partial',
            suggestion: 'Test suggestion'
          }
        }
      };

      render(<QualityScoreModal qualityScore={unknownCriteria} onClose={onClose} />);

      // Should render the unknown field as-is
      expect(screen.getByText('unknownField')).toBeInTheDocument();
    });
  });

  describe('Accessibility', () => {
    it('should have proper heading structure', () => {
      const onClose = vi.fn();
      render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} />);

      const heading = screen.getByRole('heading', { name: 'Quality Breakdown' });
      expect(heading.tagName).toBe('H2');
    });

    it('should have accessible close button', () => {
      const onClose = vi.fn();
      render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} />);

      const closeButton = screen.getByRole('button', { name: /close quality breakdown modal/i });
      expect(closeButton).toBeInTheDocument();
    });

    it('should display icons with proper styling', () => {
      const onClose = vi.fn();
      const { container } = render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} />);

      const icons = container.querySelectorAll('svg');
      expect(icons.length).toBeGreaterThan(0);
    });

    it('should have proper color contrast for text', () => {
      const onClose = vi.fn();
      render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} />);

      // Check that text colors are defined
      expect(screen.getByText('Quality Breakdown')).toHaveClass('text-slate-900');
      expect(screen.getByText('85/100')).toHaveClass('text-purple-600');
    });

    it('should have proper ARIA attributes for dialog', () => {
      const onClose = vi.fn();
      render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} />);

      const dialog = screen.getByRole('dialog');
      expect(dialog).toHaveAttribute('aria-modal', 'true');
      expect(dialog).toHaveAttribute('aria-labelledby', 'quality-modal-title');
    });

    it('should have modal title with correct id', () => {
      const onClose = vi.fn();
      render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} />);

      const title = screen.getByText('Quality Breakdown');
      expect(title).toHaveAttribute('id', 'quality-modal-title');
    });
  });

  describe('Focus Management', () => {
    // Note: Focus trap was removed. Only basic focus management remains (store/restore previous focus).
    it('should not auto-focus when modal is closed', () => {
      const onClose = vi.fn();
      render(<QualityScoreModal qualityScore={null} onClose={onClose} />);

      expect(document.activeElement).toBe(document.body);
    });

    // TODO: Test is skipped due to jsdom limitations with focus management
    it.skip('should restore focus when modal closes', () => {
      const onClose = vi.fn();
      const { rerender } = render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} />);

      const closeButton = screen.getByLabelText('Close quality breakdown modal');
      expect(document.activeElement).toBe(closeButton);

      // Close modal
      rerender(<QualityScoreModal qualityScore={null} onClose={onClose} />);

      // Modal should not be in document
      expect(screen.queryByRole('dialog')).not.toBeInTheDocument();
    });
  });

  describe('Responsive Design', () => {
    it('should have responsive modal width', () => {
      const onClose = vi.fn();
      const { container } = render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} filename="test.js" />);

      const modal = container.querySelector('.max-w-4xl.w-full');
      expect(modal).toBeInTheDocument();
    });

    it('should have responsive padding', () => {
      const onClose = vi.fn();
      const { container } = render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} filename="test.js" />);

      const overlay = container.querySelector('.p-4');
      expect(overlay).toBeInTheDocument();
    });

    it('should have max height constraint', () => {
      const onClose = vi.fn();
      const { container } = render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} filename="test.js" />);

      const modal = container.querySelector('.max-h-\\[90vh\\]');
      expect(modal).toBeInTheDocument();
    });
  });

  describe('Tabs Navigation', () => {
    it('should render Input Code Health tab', () => {
      const onClose = vi.fn();
      render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} filename="test.js" />);

      const inputTab = screen.getByRole('button', { name: /input code health/i });
      expect(inputTab).toBeInTheDocument();
    });

    it('should render Generated Documentation tab', () => {
      const onClose = vi.fn();
      render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} filename="test.js" />);

      const outputTab = screen.getByRole('button', { name: /generated documentation/i });
      expect(outputTab).toBeInTheDocument();
    });

    it('should switch between tabs on click', async () => {
      const user = userEvent.setup();
      const onClose = vi.fn();
      render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} filename="test.js" />);

      const inputTab = screen.getByRole('button', { name: /input code health/i });
      const outputTab = screen.getByRole('button', { name: /generated documentation/i });

      // Click on Input Code Health tab
      await user.click(inputTab);
      expect(inputTab).toHaveClass('border-purple-600');

      // Click on Generated Documentation tab
      await user.click(outputTab);
      expect(outputTab).toHaveClass('border-purple-600');
    });

    it('should display input code health breakdown when Input tab is active', async () => {
      const user = userEvent.setup();
      const onClose = vi.fn();
      render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} filename="test.js" />);

      const inputTab = screen.getByRole('button', { name: /input code health/i });
      await user.click(inputTab);

      // Check for input code health specific criteria
      expect(screen.getByText('Comments')).toBeInTheDocument();
      expect(screen.getByText('Naming Quality')).toBeInTheDocument();
      expect(screen.getByText('Existing Documentation')).toBeInTheDocument();
      expect(screen.getByText('Code Structure')).toBeInTheDocument();
    });

    it('should display generated documentation breakdown when Output tab is active', async () => {
      const user = userEvent.setup();
      const onClose = vi.fn();
      render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} filename="test.js" />);

      const outputTab = screen.getByRole('button', { name: /generated documentation/i });
      await user.click(outputTab);

      // Check for generated documentation specific criteria
      expect(screen.getByText('Overview')).toBeInTheDocument();
      expect(screen.getByText('Installation')).toBeInTheDocument();
      expect(screen.getByText('Usage Examples')).toBeInTheDocument();
    });

    it('should have fixed height content area to prevent jumping', () => {
      const onClose = vi.fn();
      const { container } = render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} filename="test.js" />);

      const contentArea = container.querySelector('.h-\\[420px\\]');
      expect(contentArea).toBeInTheDocument();
    });
  });

  describe('Transformation Header', () => {
    it('should display input code score', () => {
      const onClose = vi.fn();
      render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} filename="test.js" />);

      expect(screen.getByText('25/100')).toBeInTheDocument();
    });

    it('should display sparkle icon', () => {
      const onClose = vi.fn();
      const { container } = render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} filename="test.js" />);

      // Look for Sparkles icon (lucide-react renders as svg)
      const sparkleIcons = container.querySelectorAll('svg');
      const hasSparkle = Array.from(sparkleIcons).some(svg =>
        svg.classList.contains('text-purple-600') || svg.classList.contains('text-purple-400')
      );
      expect(hasSparkle).toBe(true);
    });

    it('should display arrow indicator', () => {
      const onClose = vi.fn();
      render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} filename="test.js" />);

      // Arrow should be rendered as text
      const arrow = screen.getByText('â†’');
      expect(arrow).toBeInTheDocument();
    });

    it('should display improvement points when improvement is positive', () => {
      const onClose = vi.fn();
      render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} filename="test.js" />);

      expect(screen.getByText('+60')).toBeInTheDocument();
    });

    it('should not display improvement when improvement is null', () => {
      const onClose = vi.fn();
      const scoreWithoutImprovement = {
        ...mockQualityScore,
        improvement: null
      };
      render(<QualityScoreModal qualityScore={scoreWithoutImprovement} onClose={onClose} filename="test.js" />);

      expect(screen.queryByText(/^\+/)).not.toBeInTheDocument();
    });

    it('should not display improvement when improvement is zero or negative', () => {
      const onClose = vi.fn();
      const scoreWithZeroImprovement = {
        ...mockQualityScore,
        improvement: 0
      };
      render(<QualityScoreModal qualityScore={scoreWithZeroImprovement} onClose={onClose} filename="test.js" />);

      expect(screen.queryByText(/^\+0/)).not.toBeInTheDocument();
    });

    it('should use grid layout for transformation section', () => {
      const onClose = vi.fn();
      const { container } = render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} filename="test.js" />);

      const gridContainer = container.querySelector('.grid.grid-cols-3');
      expect(gridContainer).toBeInTheDocument();
    });
  });

  describe('Download Functionality', () => {
    let mockLink;
    let blobCalls;
    let originalBlob;

    beforeEach(() => {
      // Save original Blob
      originalBlob = global.Blob;

      // Track blob calls manually
      blobCalls = [];
      global.Blob = class extends originalBlob {
        constructor(content, options) {
          super(content, options);
          blobCalls.push({ content, options });
        }
      };

      // Mock URL.createObjectURL and URL.revokeObjectURL
      global.URL.createObjectURL = vi.fn(() => 'mock-url');
      global.URL.revokeObjectURL = vi.fn();

      // Mock document.createElement and click
      mockLink = {
        click: vi.fn(),
        href: '',
        download: '',
        style: {}
      };
      vi.spyOn(document, 'createElement').mockReturnValue(mockLink);
      vi.spyOn(document.body, 'appendChild').mockImplementation(() => {});
      vi.spyOn(document.body, 'removeChild').mockImplementation(() => {});
    });

    afterEach(() => {
      // Restore original Blob
      global.Blob = originalBlob;
      vi.restoreAllMocks();
      blobCalls = [];
    });

    it('should render download button', () => {
      const onClose = vi.fn();
      render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} filename="test-file.js" />);

      const downloadButton = screen.getByRole('button', { name: /download report/i });
      expect(downloadButton).toBeInTheDocument();
    });

    it('should generate filename in correct format', async () => {
      const user = userEvent.setup();
      const onClose = vi.fn();
      render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} filename="user-service.rb" />);

      const downloadButton = screen.getByRole('button', { name: /download report/i });
      await user.click(downloadButton);

      expect(mockLink.download).toMatch(/^quality-report-user-service-readme-\d{14}\.md$/);
    });

    it('should generate markdown format with proper headers', async () => {
      const user = userEvent.setup();
      const onClose = vi.fn();
      render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} filename="test.js" />);

      const downloadButton = screen.getByRole('button', { name: /download report/i });
      await user.click(downloadButton);

      // Check that Blob was created with markdown content
      expect(blobCalls.length).toBeGreaterThan(0);
      const content = blobCalls[0].content[0];
      expect(content).toContain('# Documentation Quality Report');
      expect(content).toContain('## Summary');
      expect(content).toContain('## Input Code Health Breakdown');
      expect(content).toContain('## Generated Documentation Breakdown');
    });

    it('should include source filename in report', async () => {
      const user = userEvent.setup();
      const onClose = vi.fn();
      render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} filename="my-script.py" />);

      const downloadButton = screen.getByRole('button', { name: /download report/i });
      await user.click(downloadButton);

      expect(blobCalls.length).toBeGreaterThan(0);
      const content = blobCalls[0].content[0];
      expect(content).toContain('**Source File:** `my-script.py`');
    });

    it('should include doc type in report', async () => {
      const user = userEvent.setup();
      const onClose = vi.fn();
      render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} filename="test.js" />);

      const downloadButton = screen.getByRole('button', { name: /download report/i });
      await user.click(downloadButton);

      expect(blobCalls.length).toBeGreaterThan(0);
      const content = blobCalls[0].content[0];
      expect(content).toContain('**Document Type:** README');
    });

    it('should include generation timestamp in report', async () => {
      const user = userEvent.setup();
      const onClose = vi.fn();
      render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} filename="test.js" />);

      const downloadButton = screen.getByRole('button', { name: /download report/i });
      await user.click(downloadButton);

      expect(blobCalls.length).toBeGreaterThan(0);
      const content = blobCalls[0].content[0];
      expect(content).toContain('**Generated:**');
    });

    it('should include both input and output breakdowns in report', async () => {
      const user = userEvent.setup();
      const onClose = vi.fn();
      render(<QualityScoreModal qualityScore={mockQualityScore} onClose={onClose} filename="test.js" />);

      const downloadButton = screen.getByRole('button', { name: /download report/i });
      await user.click(downloadButton);

      expect(blobCalls.length).toBeGreaterThan(0);
      const content = blobCalls[0].content[0];
      // Check for input code health criteria
      expect(content).toContain('Comments');
      expect(content).toContain('Naming Quality');
      // Check for generated documentation criteria
      expect(content).toContain('Overview');
      expect(content).toContain('Installation');
    });
  });
});
